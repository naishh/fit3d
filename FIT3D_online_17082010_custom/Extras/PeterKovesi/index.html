<html>
<head>
<title>Peter's Functions for Computer Vision</title>
<meta NAME="keywords" CONTENT="MATLAB,image processing,computer vision,phase congruency,edge detection,image enhancement, ransac">

<meta NAME="description" CONTENT="MATLAB Functions for Computer Vision and Image Analysis. Functions include: Feature detection from Phase Congruency, Edge linking and segment fitting, Projective geometry, Image enhancement, and many others">

<meta http-equiv="refresh">
<meta http-equiv="Expires" content="Tue, 20 Aug 1996 14:25:27 GMT">

</head>
<body bgcolor="#ffffff", marginwidth="20", marginheight="20">

<center>
<h1>MATLAB and Octave Functions <br>
for Computer Vision and Image Processing</h1>
</center>

<hr>

<table>
<tr>
<td width = 60%>
<h3><a href=http://www.csse.uwa.edu.au/~pk>Peter Kovesi</a></h3>
<H4>
School of Computer Science & Software Engineering<br>
The University of Western Australia <br>
Crawley, Western Autralia. 6009
</h4>

<td width=40%>


</table>

<hr>

Please report any bugs and/or suggest enhancements to<br>
<img src="http://www.csse.uwa.edu.au/~pk/pkem14b.png">


<p>Please note that I receive so many mail messages regarding this
site that I have difficulty responding to them all.  
I do not have the time to provide an on-line vision
problem solving service!  However, I will endeavor to respond to mail
that directly concerns the use of individual functions.


<p>Cheers,<br>
Peter Kovesi

<!--<img src="http://www.cs.uwa.edu.au/images/new.gif"> -->
<!--<img src="http://www.cs.uwa.edu.au/images/updated.gif"> -->

<br><br><br>

<hr>

The complete set of these functions is available as a gzipped tar file 
<a href="../MatlabFns.tar.gz">MatlabFns.tar.gz</a> for Unix users.<br>

Once you have untarred this file MATLAB users should remove the Octave
subdirectory from this package (or ensure it is not in your MATLAB
path) to avoid problems.

<!--, or as a zip file
<a href="../MatlabFns.zip">MatlabFns.zip</a> for Windows users.  -->

<p>
Note that I develop my code under Mac OS X.

<ul>
<li><a href=citesite.html>How to cite this site</a>
<li><a href=license.html>MIT License</a>


<li><a href=octaveinfo.html>Notes on using Octave</a> - almost all of
these functions run under Octave.  With the release of Octave 3 you
have a very viable alternative to MATLAB.
  
</ul>

  <p> Legend for MATLAB/Octave compatibility
  <ul>
  <li type=square> Runs under MATLAB and Octave.
  <li type=circle> Only runs under MATLAB.
  <li type=disc> Not tested under Octave (yet).
  </ul>


<br>
<p>Can't find what you want here? Have a look at<br>
<a href=othersites.html>Other highly recommended Computer Vision software sites</a>

<a name="phasecong"></a>
<hr>
<h4>Feature detection via Phase Congruency</h4>
 
<center><img align=top src=WWWImages/baboon.pc.gif> </center><br>
<ul>

<li type=square><a href=PhaseCongruency/phasecong.m>phasecong.m</a> Code for
calculating phase congruency in an image.  Phase congruency is an
illumination and contrast invariant measure of feature
significance. It also correctly detects features at <i>all</i> kind of
phase angle, and not just step features with a phase angle of 0 or 180
degrees.  This function also returns a feature type image.  Note
however, this function is now only here for reference reasons, I now
recommend that you use phasecong2 below.

<li type=square>
<a href=PhaseCongruency/phasecong2.m>phasecong2.m</a> New phase
congruency code that combines edge and corner detection, and provides
better localization.  This function supersedes phasecong.m above.

<li type=circle><a href=PhaseCongruency/dispfeat.m>dispfeat.m</a> This
function provides visualisation and statistics of the different
feature types found in an image by phasecong.  Typically you will find
a broad distribution of all feature types between step edges and
lines.  This function needs <a
href=LineSegments/edgelink.m>edgelink.m</a> (see below).

<li type=square><a href=PhaseCongruency/odot.m>odot.m</a> Demonstrates
the actions of the 'Odot' and 'Oslash' operators on a 1D signal.
These operators allow one to decompose and combine signals in a way
that is consistent with the Local Energy model of feature perception.

<li><a href=PhaseCongruency/spatialgabor.m>spatialgabor.m</a> applies
a single oriented Gabor filter to an image.

<center>
<table width=50%>
<tr>
<td><img align=top src=WWWImages/whalesm.jpg> <br>&nbsp; <td><center> <img align=top
src=WWWImages/whalesmsym.jpg> <br>phase symmetry image</center>
</tr></table></center>

<li type=square><a href=PhaseCongruency/phasesym.m>phasesym.m</a> Code for
calculating phase symmetry. This can be used as a line and blob
detector.  Phase symmetry is an illumination and contrast invariant
measure of symmetry in an image.  (A bright circle is not more
'symmetric' than a grey circle as can be the case with some other
measures!).

<li type=square><a
href=PhaseCongruency/gaborconvolve.m>gaborconvolve.m</a> Code for
convolving an image with a bank of log-Gabor filters.  A
pre-processing step for texture analysis, feature detection and
classification, etc.

<li type=circle><a
href=PhaseCongruency/plotgaborfilters.m>plotgaborfilters.m</a> A
function for plotting log-Gabor filters.  This function is useful for
seeing what effect the various parameter settings have on the
formation of a log-Gabor filter bankused in the functions above.

<li type=square><a href=PhaseCongruency/monofilt.m>monofilt.m</a> An
implementation of Felsberg's monogenic filters.  This function applies
a bank of monogenic filters to an image to obtain the 2D analytic signal
over a number of scales.  As in gaborconvolve this can be used as a
pre-processing step for texture analysis, feature detection and
classification, etc.

<li><a href=PhaseCongruency/Docs/convexpl.html>An explanation</a> of
the implementation of convolution with log-Gabor filters used in the
functions above. 

</ul>

<p><b>References:</b>
<ul>

<li> Peter Kovesi, 
     <a href="http://www.csse.uwa.edu.au/~pk/research/pkpapers/ai97.pdf">
     "Symmetry and Asymmetry From Local Phase".</a> AI'97, Tenth
     Australian Joint Conference on Artificial Intelligence.  2 - 4
     December 1997. Proceedings - Poster Papers. pp 185-190.

<li> Peter Kovesi, 
     <a href="http://mitpress.mit.edu/e-journals/Videre/001/v13.html"> 
     "Image Features From Phase Congruency".</a> 
     <i>Videre: A Journal of Computer Vision Research</i>. MIT
     Press. Volume 1, Number 3, Summer 1999.

<li> Peter Kovesi,
     <a href="http://www.csse.uwa.edu.au/~pk/research/pkpapers/ACCV62.pdf">
     "Edges Are Not Just Steps".</a> Proceedings of <em>ACCV2002 The
     Fifth Asian Conference on Computer Vision</em>, Melbourne Jan
     22-25, 2002.  pp 822-827. 

<li> Peter Kovesi, 
     <a href="http://www.csse.uwa.edu.au/~pk/research/pkpapers/phasecorners.pdf">
     "Phase Congruency Detects Corners and Edges".</a>
     <i> The Australian Pattern Recognition Society Conference:
     DICTA 2003. </i> December 2003. Sydney. pp 309-318.

</ul>


<a name="spatial"></a>
<hr> 
<h4>Spatial feature detection</h4>
<ul>

<li type=square><a href=Spatial/canny.m>canny.m</a> Canny edge
detector incorporating modifications suggested by Fleck.

<li type=square><a href=Spatial/harris.m>harris.m</a> Harris corner
detector.

<li type=square><a href=Spatial/fastradial.m>fastradial.m</a> An
implementation of Loy and Zelinski's fast radial feature
detector. 

</ul>

<p><b>Reference:</b>
<ul>
<li><a href=Spatial/Docs/Harris/index.html>Scanned images</a> of my
photocopy of Harris and Stephens' paper 'A Combined Corner and Edge
Detector'.

</ul>

<a name="nonmax"></a>
<a name="hysthresh"></a>
<hr>
<h4>Non-maxima suppression and hysteresis thresholding</h4>

<center><img align=top src=WWWImages/baboon.pc.edge.gif></center>
<br> 
<ul>

<li type=square><a href=Spatial/nonmaxsup.m>nonmaxsup.m</a> Code for
performing non-maxima suppression for edge images.

<li type=square><a href=Spatial/nonmaxsuppts.m>nonmaxsuppts.m</a> Code
for performing non-maxima suppression and thresholding of points
generated by a feature/corner detector. It optionally returns
sub-pixel feature locations.

<li type=square> <a href=Spatial/hysthresh.m>hysthresh.m</a> code for
performing hysteresis thresholding. 

<li type=square> <a href=Spatial/smoothorient.m>smoothorient.m</a>
applies smoothing to an orientation field which can be useful before
applying nonmaximal suppression.

<li type=square> <a href=Spatial/adaptivethresh.m>adaptivethresh.m</a>
an implementation of Wellner's adaptive thresholding method.

</ul>

<a name="edgelink"></a>
<hr> 
<h4>Edge linking and line segment fitting</h4>
<center>
<table>
<tr>
<td><img align=top src=WWWImages/shapes.gif> <br> <center>image</center></td>
<td><img align=top src=WWWImages/shapese.gif> <br> <center>edges</center></td>
<td><img align=top src=WWWImages/shapeseim.gif> <br> <center>labeled edges</center></td>
<td><img align=top src=WWWImages/shapesseg.gif> <br> <center>fitted line segments</center></td>
</tr></table></center><br>
<ul>


<li><a href=LineSegments/edgelink.m>edgelink.m</a> edge
linking function that forms lists of connected edge points from a
binary edge image. (Needs findendsjunctions and cleanedgelist below).

<li><a href=LineSegments/drawedgelist.m>drawedgelist.m</a>
plots out a set of edge lists generated by edgelink or lineseg.

<li><a href=LineSegments/edgelist2image.m>edgelist2image.m</a>
transfers edgelist data back into a 2D image array.

<li><a href=LineSegments/lineseg.m>lineseg.m</a> forms
straight line segments fitted with a specified tolerance to the lists
of connected edge points.

<!-- Deprecated
<li type=square><a href=LineSegments/mergeseg.m>mergeseg.m</a> is used
by lineseg.m to merge co-linear segments that may have been separated
in the edge linking process.
<li type=square><a href=LineSegments/drawseg.m>drawseg.m</a> plots the
fitted line segments.
<li type=circle><a href=LineSegments/selectseg.m>selectseg.m</a>
allows you to interactively select segments from an image.
-->

<li type=square><a href=LineSegments/maxlinedev.m>maxlinedev.m</a> is
also used by lineseg.m to calculate deviations of the edge lists from
the fitted segments.

<li><a href=LineSegments/findendsjunctions.m>findendsjunctions.m</a>
finds line junctions and endings in a line/edge image.

<li><a href=LineSegments/cleanedgelist.m>cleanedgelist.m</a> cleans up a
set of edge lists generated by edgelink or lineseg so that isolated
edges and spurs that are shorter than a minimum length are removed.

<li><a href=LineSegments/example/index.html>Example</a> of using these
functions above.  

</ul>

<a name="step2line"></a>
<hr> 
<h4>Test grating for edge detection</h4>
<center>
<table>
<tr>
<td><img align=top src=WWWImages/step2line.gif> <br><center>Test image</center></td>
<td><img align=top src=WWWImages/step2line.canny.gif> <br><center>Canny edge image</center></td>
<td><img align=top src=WWWImages/step2line.pc.gif> <br><center>Phase congruency</center></td>
<td><img align=top src=WWWImages/step2linecoded.gif> <br><center>Colour coded for feature type</center></td>
</table> </center> <br> 
<ul>

<li type=square><a href=PhaseCongruency/step2line.m>step2line.m</a>
Generates a test image where the feature type changes from a step edge
to a line feature from top to bottom, while retaining perfect phase
congruency.  This test image indicates the importance of phase
congruency irrespective of the angle at which congruency occurs at
and, up to a point, irrespective of the rate at which the amplitude
spectrum decays with frequency.  A gradient based edge detector
produces a double response for all features that have congruence of
phase at angles other than zero (towards the bottom of the test
image).  The phase congruency detector marks features with a single
response.  The colour coded image was generated by <a
href=PhaseCongruency/dispfeat.m>dispfeat.m</a>

</ul>

<a name="noisecomp"></a>
<hr>
<h4>Image denoising</h4>
<center><img align=top src=WWWImages/srvb0019gamma-tn.jpg> &nbsp;
<img align=top src=WWWImages/gclean0019a-tn.jpg> </center><br>
<ul>

<li type=square><a href=PhaseCongruency/noisecomp.m>noisecomp.m</a>
Code for denoising images.  This code differs from standard wavelet
denoising techniques in that it uses non-orthogonal wavelets, and
unlike existing techniques, ensures that phase information is
preserved in the image. Phase information is of crucial importance to
human visual perception.  Also, this code <i>does</i> have an
effective way of determining threshold levels automatically.

<p>See the example below, under grey scale transformation and
enhancement, for an example of the use of this function.

</ul>

<p><b>Reference:</b>
<ul>
<li> Peter Kovesi, 
     <a href="http://www.csse.uwa.edu.au/~pk/research/pkpapers/denoise.pdf">
     "Phase Preserving Denoising of Images". </a>
     <i> The Australian Pattern Recognition Society Conference:
     DICTA'99. </i> December 1999. Perth WA. pp 212-217.
</ul>

<a name="shapelet"></a>
<hr>
<h4>Surface normals to Surfaces</h4>


<center>
<table>
<tr><td><img align=top src=WWWImages/rampneedlesm.png><br>
<center> Surface Normals </center></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td> <img align=top src=WWWImages/rampreconsm.png><br>
<center>Surface Reconstruction</center></td></tr>
</table>
</center>

<ul>

<li type=square><a href=Shapelet/shapeletsurf.m>shapeletsurf.m</a>
Function reconstructs an estimate of a surface from its surface
normals by correlating the surface normals with that those of a bank
of shapelet basis functions. The correlation results are summed to
produce the reconstruction.  The sumation of shapelet basis functions
results in an implicit integration of the surface while enforcing
surface continuity.

<p>Note that the reconstruction is only valid up to a scale factor
(which can be corrected for). However the reconstruction process is
very robust to noise and to missing data values.  Reconstructions (up
to positive/negative shape ambiguity) are possible where there is an
ambiguity of pi in tilt values.  Low quality reconstructions are also
possible with just slant, or just tilt data alone.  However, if you
have full gradient information you are better off with the Frankot
Chellappa algorithm below.

<li type=square><a
href=Shapelet/frankotchellappa.m>frankotchellappa.m</a> An
implementation of Frankot and Chellappa's algorithm for constructing
an integrable surface from gradient information.  If you have full
gradient information in x and y this is probably the best algorithm to
use.  It is very simple, very fast and highly robust to noise.  If you
have surface normal information in the form of slant and tilt, and you
have an ambiguity of pi in your tilt data, or only have slant, then
try using shapeltsurf.m above.


<li type=square><a href=Shapelet/grad2slanttilt.m>grad2slanttilt.m</a>
Converts gradient values over a surface to slant and tilt angles.

<li type=square><a href=Shapelet/slanttilt2grad.m>slanttilt2grad.m</a>
Converts slant and tilt angles over a surface to gradients.

<li type=square><a href=Shapelet/needleplotgrad.m>needleplotgrad.m</a>
Generates a needle plot given surface gradients over a surface.

<li type=square><a href=Shapelet/needleplotst.m>needleplotst.m</a> Generates a
needle plot given slant and tilt values over a surface.

<li type=square><a href=Shapelet/testp.m>testp.m</a> Generates a
synthetic test surface along with its surface normals for testing
shapeletsurf.


</ul>

<p><b>Reference:</b>
<ul>
<li> Peter Kovesi, 
<a href="http://www.csse.uwa.edu.au/~pk/research/pkpapers/shapeletsICCV.pdf">
"Shapelets Correlated with Surface Normals Produce Surfaces". </a>
10th IEEE International Conference on Computer Vision.
Beijing. pp 994-1001. 2005

<li><a href="http://www.csse.uwa.edu.au/~pk/Research/ShapeFromContour/index.html">
An example</a> of how much 3D shape you can get from very minimal
surface normal information.
</ul>


<a name="scalogram"></a>
<hr>
<h4>Scalogram calculation</h4>
 <center><img align=top src=WWWImages/dphase2.jpg></center> <br>
<ul>

<li type=circle><a href=FrequencyFilt/scalogram.m>scalogram.m</a>
Function to calculate the phase and amplitude scalograms of a 1D
signal. The analysis is done using quadrature pairs of log Gabor
wavelets.

</ul>

<a name="anisodiff"></a>
<hr> 
<h4>Anisotropic diffusion</h4>
<center> <img align=top src=WWWImages/Mona_LisaGs.jpg> &nbsp;
<img align=top src=WWWImages/Mona_diffuses.jpg> </center>  <br>
<ul>

<li type=square><a href=Spatial/anisodiff.m>anisodiff.m</a> Function
to perform anisotropic diffusion of an image following Perona and
Malik's algorithm.  This process smoothes regions while preserving,
and enhancing, the contrast at sharp intensity gradients.

</ul>

<a name="greytrans"></a>
<hr>
<h4>Grey scale transformation and enhancement</h4>
<ul>

<li type=square><a href=GreyTrans/extractfields.m>extractfields.m</a>
separates fields from a video frame, and optionally interpolates
intermediate lines.

<li type=square><a href=GreyTrans/interpfields.m>interpfields.m</a>
interpolates lines on a field extracted from a video frame.

<li type=square><a href=GreyTrans/normalise.m>normalise.m</a> rescales
image values to 0-1.

<li type=square><a href=GreyTrans/adjcontrast.m>adjcontrast.m</a>
adjusts image contrast using sigmoid function.

<li type=square><a href=GreyTrans/adjgamma.m>adjgamma.m</a> adjusts
image gamma.

<li type=circle><a href=GreyTrans/greytrans.m>greytrans.m</a> allows
you to interactively remap intensity values in a colour or greyscale
image via a mapping function defined by a series of spline points.  A
feeble attempt at replicating <i>xv's</i> intensity mapping tool.  It
is not as fast but it does operate on floating point images allowing
you to better preserve image fidelity. (Needs remapim.m).

<li><a href=GreyTrans/remapim.m>remapim.m</a> is a non-interactive
version of greytrans that allows you to apply an intensity mapping to
a colour or greyscale image using a mapping function determined
experimentally with greytrans.  Useful if you want to apply the same
mapping function to a sequence of images. 

<li type=square><a href=GreyTrans/histtruncate.m>histtruncate.m</a>
truncates ends of an image histogram.  Useful for enhancing images
with outlying values.

<!--<li><a href=GreyTrans/histtruncatex.m>histtruncatex.m</a> truncates
ends of an image histogram.
-->

<li> <a href=GreyTrans/example/index.html>Example</a> of using some of
these functions above to enhance a video image.

</ul>

<a name="freqfilt"></a>
<hr>
<h4>Frequency domain transformations</h4>
<ul>

<li type=square><a
href=FrequencyFilt/lowpassfilter.m>lowpassfilter.m</a> constructs
low-pass Butterworth filter.

<li type=square><a
href=FrequencyFilt/highpassfilter.m>highpassfilter.m</a> constructs
high-pass Butterworth filter.

<li type=square><a
href=FrequencyFilt/highboostfilter.m>highboostfilter.m</a> constructs
high-boost Butterworth filter.

<li type=square><a
href=FrequencyFilt/bandpassfilter.m>bandpassfilter.m</a> constructs
band-pass Butterworth filter.

<li type=square><a href=FrequencyFilt/homomorphic.m>homomorphic.m</a>
performs homomorphic filtering on an image.  One of my favourite image
enhancement techniques. (needs histtruncate.m and normalise.m)

<!--
<li><a href=FrequencyFilt/homomorphicGUI.m>homomorphicGUI.m</a> GUI
interface to homomorphic. (needs homomorphic.m) This code is a bit
flakey under version 6.0 R12, I think it is OK under 6.1
-->

<li type=square><a href=FrequencyFilt/psf.m>psf.m</a> generates a
variety of point-spread functions.  This function can be useful when
manually specifying point-spread functions for Wiener filtering or
with deconvolution functions such as the Richardson-Lucy algorithm
(see the MATLAB image toolbox function deconvlucy.m).

<li type=square><a href=FrequencyFilt/psf2.m>psf2.m</a> is identical
to psf, it just has a different way of specifying the function shape
which may be more convenient for some applications.

<li type=square><a href=FrequencyFilt/imspect.m>imspect.m</a> plots
image amplitude spectrum averaged over all orientations.

<li type=circle><a href=FrequencyFilt/freqcomp.m>freqcomp.m</a>
demonstrates image reconstruction from its Fourier components.

</ul>

<a name="projective"></a>
<hr>
<h4> Functions supporting projective geometry</h4>
<center>
<table><tr>
<td><img align=top src=WWWImages/trigg.jpg><br><center>image of beach</center></td>
<td><img align=top src=WWWImages/recttrigg.jpg><br><center>rectified beach</center></td>
</tr></table>
</center>

<ul>

<li type=square> <a href=Projective/homography1d.m>homography1d.m</a>
computes the 2x2 1D homography of 3 or more points along a line.

<li type=square> <a href=Projective/homography2d.m>homography2d.m</a>
computes the 3x3 2D homography of 4 or more points in a plane.  This
code follows the normalised direct linear transformation algorithm
given by Hartley and Zisserman.

<li type=square> <a href=Projective/fundmatrix.m>fundmatrix.m</a>
computes the fundamental matrix from 8 or more matching points in a
stereo pair of images using the normalised 8 point algorithm.

<li type=square> <a
href=Projective/affinefundmatrix.m>affinefundmatrix.m</a> computes the
affine fundamental matrix from 4 or more matching points in a stereo
pair of images.

<li type=square> <a
href=Projective/normalise2dpts.m>normalise2dpts.m</a> translates and
normalises a set of 2D homogeneous points so that their centroid is at
the origin and their mean distance from the origin is sqrt(2).  This
is used to improve the conditioning of any equations used to solve
homographies, fundamental matrices etc.

<li type=square> <a href=Projective/hnormalise.m>hnormalise.m</a>
normalises an array of homogeneous coordinates so that their scale
parameter is 1. Points at infinity are unchanged.

<li> <a href=Projective/imTrans.m>imTrans.m</a> applies a homogeneous
transform to an image.

<li type=circle> <a href=Projective/digiplane.m>digiplane.m</a> allows
you to digitise and transform points within a planar region in an
image.


<li> <a
href=Projective/equalAngleConstraint.m>equalAngleConstraint.m</a> Affine
transform constraints given two equal angles.

<li> <a
href=Projective/knownAngleConstraint.m>knownAngleConstraint.m</a> Affine
transform constraints given a known angle.

<li> <a
href=Projective/lengthRatioConstraint.m>lengthRatioConstraint</a> Affine
transform constraints given a length ratio.

<li> <a href=Projective/circleintersect.m>circleintersect.m</a> Finds
intersection of two circles. Use this function to solve for affine
transformation constraints.

<li type=square> <a href=Projective/circle.m>circle.m</a> Draws a
circle.

<li type=square> <a href=Projective/hcross.m>hcross.m</a> Homogeneous
cross product, result normalised to s = 1.

<li type=circle> <a href=Projective/hline.m>hline.m</a> Plot 2D lines
defined in homogeneous coordinates.

<li type=square> <a href=Projective/homoTrans.m>homoTrans</a> 2D homogeneous
transformation of points/lines.

<li type=square> <a href=Projective/plotPoint.m>plotPoint.m</a> Plots
point with specified mark and optional text label.

<p><li> If you are using these functions above you should look at Andrew
Zisserman's <a href="http://www.robots.ox.ac.uk/~vgg/hzbook/code/">
MATLAB Functions for Multiple View Geometry</a>

</ul>



<a name="match"></a>
<hr>
<h4>Matching</h4>
<ul>

<li type=square><a
href=Match/matchbycorrelation.m>matchbycorrelation.m</a> generates
putative matches between previously detected feature points in two
images by looking for points that are maximally correlated with each
other within windows surrounding each point.  Only points that
correlate most strongly with each other in both directions are
returned.  This is a simple-minded N<sup>2</sup> comparison.

<li type=square><a
href=Match/matchbymonogenicphase.m>matchbymonogenicphase.m</a> is
similar to matchbycorrelation, but instead matches on oriented phase
values rather than greyscale values.  This matcher performs rather
well relative to normalised greyscale correlation.  Typically there
are more putative matches found and fewer outliers.  There is a
greater computational cost in the pre-filtering stage but potentially
the matching stage is much faster as each pixel is effectively encoded
with only 3 bits. (Though this potential speed is not realized in this
implementation). See <a href=Robust/example/testfund.m>testfund</a>
below to see an example of the use of this function.

</ul>

<a name="robust"></a>
<hr>
<h4>Model fitting and Robust estimation</h4>

<center>
<table><tr>
<td><img align=top src=Robust/example/putativesm.jpg><br>
Putative matches obtained<br>by <a href=Match/matchbycorrelation.m>matchbycorrelation.m</a></td>
<td>&nbsp; &nbsp;</td>
<td><img align=top src=Robust/example/inlierssm.jpg><br>
Inlying matches consistent<br>with fundamental matrix</td>
</tr></table>
</center>

<ul>
<li type=square><a href=Robust/ransac.m>ransac.m</a> a general purpose
implementation of the RANSAC algorithm.  <img
src="http://www.cs.uwa.edu.au/images/updated.gif"> August 2008 This
should be fixed now - sorry for any problems you had<br>


<li type=square><a href=Robust/ransacfithomography.m>ransacfithomography.m</a>
robustly fits a homography to a set of putatively matched image points. 

<li type=square><a
href=Robust/ransacfitfundmatrix.m>ransacfitfundmatrix.m</a> robustly
fits a fundamental matrix to a set of putatively matched image points.
This function uses an 8 point fundamental matrix solution.

<li><a
href=Robust/ransacfitfundmatrix7.m>ransacfitfundmatrix7.m</a> robustly
fits a fundamental matrix to a set of putatively matched image points.
This function requires Andrew Zisserman's 7 point fundamental matrix code
available from: <a href="http://www.robots.ox.ac.uk/~vgg/hzbook/code/">
MATLAB Functions for Multiple View Geometry</a>

<li type=square><a
href=Robust/ransacfitaffinefund.m>ransacfitaffinefund.m</a> robustly
fits an affine fundamental matrix to a set of putatively matched image
points.

<li type=square><a href=Robust/ransacfitplane.m>ransacfitplane.m</a>
robustly fits a plane to 3D data points.

<li type=square><a href=Robust/ransacfitline.m>ransacfitline.m</a>
robustly fits a line to 3D data points.

<li type=square><a href=Robust/iscolinear.m>iscolinear.m</a> tests if
3 points are colinear, used by ransacfitplane and ransacfithomography.

<li type=square><a href=Robust/fitline.m>fitline.m</a> least squares
fit of a line to 2D data points.

<li type=square><a href=Robust/fitline3d.m>fitline3d.m</a> least squares
fit of a line to 3D data points. Contributed by Felix Duvallet.

<li type=square><a href=Robust/fitplane.m>fitplane.m</a> least squares
fit of a plane to 3D data points.

<li type=square><a href=Robust/example/testfitplane.m>testfitplane</a>
example of using ransacfitplane.m

<li type=square><a href=Robust/example/testfitline.m>testfitline</a>
example of using ransacfitline.m

<li type=square><a href=Robust/example/testfund.m>testfund</a>
example of using ransacfitfundmatrix.m

<li type=square><a href=Robust/example/testhomog.m>testhomog</a>
example of using ransacfithoography.m

<li type=square><a href=Robust/randomsample.m>randomsample</a> a basic
replacement for <tt>randsample</tt> to be used with <tt>ransac.m</tt>
should you not have the statistics toolbox, or are using Octave.

<li><a href=Robust/example/index.html>Example</a> of using these
functions above to find the fundamental matrix.  

</ul>

<!--
<a name="lensdistort"></a>
<hr>

<h4>Lens Distortion Correction</h4>

<center>
<table><tr>
<td><img align=top src=WWWImages/distortsm.jpg><br><center>original image</center></td>
<td><img align=top src=WWWImages/correctedsm.jpg><br><center>corrected image</center></td>
</tr></table>
</center>

<p>Sorry, this code is broken due to changes I have made to the edge
linking code above.  Hopefully I will get round to fixing it soon.

<ul>
<li><a href=LensDistort/lensparam.m>lensparam.m</a> Estimates lens
distortion parameters.  This is an implementation of Devernay and
Faugeras' technique for lens distortion removal from structured
scenes.  Edges are detected in the image and line segments fitted to
the edges.  If an edge is curved it will deviate from the fitted
segment.  An optimisation process is performed on the lens distortion
parameters in order to minimize the deviation of the edge points from
straight lines.

<li><a href=LensDistort/imlenstransform.m>imlenstransform.m</a> This
function applies or inverts a lens distortion transformation defined
by first order coefficients to an image.

<li><a href=LensDistort/crookedness.m>crookedness.m</a> Returns a
measure of the 'crookedness' of a set of lines. This is the objective
function passed to the optimisation function by lensparam.m.

<li><a
href=LensDistort/edgelistlenscorrect.m>edgelistlenscorrect.m</a> This
function corrects for lens distortion defined by first order
coefficients on an edgelist.

<li><a href=LensDistort/example/index.html>Example</a> of the use of
these functions.  

</ul>


<p>These functions make use of:<br>
drawedgelist.m, 
edgelink.m, 
lineseg.m, 
maxlinedev.m, 
mergeseg.m, 
implace.m, 
removenan.m, 
show.m, 
fitline.m
-->

<a name="fingerprints"></a>
<hr>
<h4>Fingerprint enhancement</h4>

<center>
<table><tr>
<td><img align=top src=WWWImages/fingervsm.png></td>
<td>&nbsp; &nbsp;</td>
<td><img align=top src=WWWImages/finalvsm.png></td>
</tr></table>
</center>

<ul>
<li><a href=FingerPrints/ridgesegment.m>ridgesegment.m</a> identifies
ridge-like regions of a fingerprint image.  It also normalises the
intensity values of the image.

<li><a href=FingerPrints/ridgeorient.m>ridgeorient.m</a> estimates the
local orientation of ridges in a fingerprint.

<li><a href=FingerPrints/plotridgeorient.m>plotridgeorient.m</a> plots
ridge orientations calculated by ridgeorient.

<li><a href=FingerPrints/ridgefreq.m>ridgefreq.m</a> estimates the
local ridge frequency across a fingerprint image.

<li><a href=FingerPrints/freqest.m>freqest.m</a> estimates the ridge
frequency within a small block of an image.  This is used by
ridgefreq.

<li><a href=FingerPrints/ridgefilter.m>ridgefilter.m</a> enhances
a fingerprint image using oriented filters.

<li><a href=FingerPrints/Docs/index.html>Example</a> of using these functions above.
</ul>

<hr> 
<h4>Interesting images </h4>
<center><img align=top src=WWWImages/clouds.gif></center><br> 
<ul>

<li type=square><a href=Misc/noiseonf.m>noiseonf.m</a> generates noise
images with specified amplitude spectra.  One can create pleasing
cloud pattern images this way.

<li type=circle> <a href=Misc/cloud9.m>cloud9.m</a> creates a movie
sequence of noise images with specified amplitude spectra.  Very
relaxing.

</ul>    
<br><br>
<center><img align=top src=WWWImages/derespk.gif></center> <br>

<ul>
<li type=square><a href=Misc/derespolar.m>derespolar.m</a> Generates
deresolved images in polar coordinates.

<li><a href=Misc/polartrans.m>polartrans.m</a> Generates a polar
transformation of an image.  A linear or logarithmic radius
transformation can be specified.

<li type=square><a href=FrequencyFilt/circsine.m>circsine.m</a>
Generates a test image consisting of a circular sine wave grating.

</ul>
     
<hr>
<h4>ASCII Image Generation</h4>
<center> <img align=top src=WWWImages/MonaASCIIsml.gif></center> <br>
<ul>

<li type=square><a href=Misc/matscii.m>matscii.m</a> Function to
generate ASCII images from grey scale images. A bit retro but may have
applications for interesting text messages on your mobile phone!
</ul>
     
<hr>

<a name="display"></a>
<h4>Image Display, Image Writing and Miscellaneous</h4>
<ul>

<li type=square><a href=Misc/show.m>show.m</a> This function displays
an image, automatically setting the colour map to grey if it is a 2D
image, or leaving it as colour otherwise, and setting the axes to be
'equal'.  The image is also displayed as 'TrueSize', that is, pixels
on the screen match pixels in the image.  Finally a title
corresponding to the image variable name is added.

<li type=square><a href=Misc/showfft.m>showfft.m</a> displays the
amplitude spectrum of an fft.

<li type=square><a href=Misc/showlogfft.m>showlogfft.m</a> displays
the log amplitude spectrum of an fft.

<li type=square><a href=Misc/imwritesc.m>imwritesc.m</a> This function
combines image rescaling and writing into the one function.  If the
image type is <tt>double</tt> image values are rescaled to the range
0-1 so that no overflow occurs when writing 8-bit intensity values.
The image format to use is determined by MATLAB from the file ending.
If the image type is of <tt>uint8</tt> no rescaling is performed.

<li type=square><a href=Misc/matprint.m>matprint.m</a> This function
prints out a matrix using a specified C style format string.  Often
you find that MATLAB's default number formats are not what you want.
It is surprising that there is no convenient fine control of output
format.  I hope this function helps.

<li type=square><a href=Misc/removenan.m>removenan</a> Replaces NaN
values in a matrix with a specified default value.  Useful when you
want to prevent NaNs from contaminating and destroying some operation
on an array, for example, an FFT.

<li><a href=Misc/fillnan.m>fillnan</a> Replaces NaN
values in a matrix with the value in the closest non-Nan pixel.

<li type=square><a href=Misc/digipts.m>digipts.m</a> Function to
digitise points in an image.  This function uses the cross-hair cursor
provided by GINPUT.  I find this is much more useable than the cursor
used by IMPIXEL. In addition each location digitised is marked with a
red '+'.

<li type=square><a href=Misc/implace.m>implace.m</a> Function to place
an image at a specified location within a larger image.

</ul>

<hr>



<!-- Start of StatCounter Code -->
<script type="text/javascript" language="javascript">
var sc_project=2025066; 
var sc_invisible=1; 
var sc_partition=18; 
var sc_security="bc8bdd58"; 
</script>

<script type="text/javascript" language="javascript" 
src="http://www.statcounter.com/counter/counter.js">
</script>
<noscript><a href="http://www.statcounter.com/" target="_blank">
<img  src="http://c19.statcounter.com/counter.php?sc_project=2025066&java=0&security=bc8bdd58&invisible=1" 
alt="web hit counter" border="0"></a> 
</noscript>
<!-- End of StatCounter Code -->


</BODY>
</HTML>


